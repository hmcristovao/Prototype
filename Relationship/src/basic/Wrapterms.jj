/*  Wrapterms.jj  -  It wraps terms to SPARQL query */
options {
  DEBUG_PARSER = false;
  DEBUG_TOKEN_MANAGER = false;
  STATIC = false;
}
PARSER_BEGIN(Wrapterms)
package basic;

import java.io.*;
import myClasses.*; 

public class Wrapterms {
   
   public static void main(String args[])  throws ParseException  {
      Wrapterms parser = null;
      try {
         parser = new Wrapterms(new FileInputStream("terms.txt"));
         ListQuerySparql originalList = new ListQuerySparql();
         parser.start(originalList);
		 System.out.println("originalList=\n");
         System.out.println(originalList);
         System.out.println("\n"+originalList.getListConcept());
         originalList.fillQuery();
		 System.out.println("originalList (after fill query)=\n");
         System.out.println(originalList);
         
      }
      catch(FileNotFoundException e) {
         System.out.println("Error: file not found.");
      }
      catch (IOException e) {
		 System.out.println("Error: problem with the persistent file: " + e.getMessage());
	  }
      catch(TokenMgrError e) {
         System.out.println("Lexical error: " + e.getMessage());
      }
       catch(SemanticException e) {
         System.out.println("Semantic error: " + e.getMessage());
      }
      catch(ParseException e) {
         System.out.println("Sintax error: " + e.getMessage());
      }
   }
}
PARSER_END(Wrapterms)
TOKEN : {
      < CHARACTER:  ["a"-"z","A"-"Z","0"-"9","-","_"] > |
      < TERM:       < CHARACTER > 
                    (
                      ( < CHARACTER > | " " )*
                      < CHARACTER >
                    )?
      > |
      < SEPARATORS:  ( "\n" | "\r" | "," | ";" | "/" | " " )+ >
}
/* Gramar:
start   ->  ( element() )*  < EOF > 
element ->  < TERM > ( < SEPARATORS > )*
*/

void start(ListQuerySparql originalList) : {} 
{
   ( element(originalList) )* < EOF >
}
void element(ListQuerySparql originalList) : {Token token; Concept concept;}  
{
	token = < TERM >
    {		concept = new Concept(token);
		originalList.insert(concept);			
    }
    ( < SEPARATORS > )*
}

