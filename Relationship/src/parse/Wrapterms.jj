/*  Wrapterms.jj  -  It wraps terms to SPARQL query */ 
options {
  DEBUG_PARSER = false;
  DEBUG_TOKEN_MANAGER = false;
  STATIC = false;
}
PARSER_BEGIN(Wrapterms)
package parse;

import java.io.*;
import main.*;
import user.*;
import rdf.*;
import map.*;
import graph.*;

public class Wrapterms {
   public static void main(String args[])  throws Exception {
      Wrapterms firstParser = null;
	  MainProcess.body(firstParser);
   }
}
PARSER_END(Wrapterms)
TOKEN : {
      < ARROW:          "->" > |
      < CHARACTER:      ["a"-"z","A"-"Z","0"-"9","_",":","#",".","\'"] > |
      < TERM:           < CHARACTER > 
                        (
                          ( < CHARACTER > | " " | < CHARACTER > "-" )*
                            < CHARACTER >
                        )?
      > |
      < SEPARATORS:  ( "\n" | "\r" | "\t" | "," | ";" | " " )+ > 
 }
/*
Grammar (read of user terms):
parseUserTerms        ->  ( elementUserTerm() )*  < EOF > 
element               ->  < TERM > ( < SEPARATORS > )*

Grammar (read of link vocabulary):
parseSystemVocabulary ->  ( line() )*  < EOF >
line                  ->  < TERM > < ARROW > < TERM > ( < SEPARATORS > )*

Grammar (read of useless concepts):
parseUserTerms        ->  ( elementUselessConcept() )*  < EOF > 
elementUselessConcept ->  < TERM > ( < SEPARATORS > )*

*/

// list of user terms, separate for comma or new line 
void parseUserTerms(SetQuerySparql originalSetQuerySparql) : {} 
{
   ( elementUserTerm(originalSetQuerySparql) )* < EOF >
}
void elementUserTerm(SetQuerySparql originalSetQuerySparql) : {Token token; Concept concept;}  
{
	token = < TERM >
    {		concept = new Concept(token);
		originalSetQuerySparql.insertQuerySparql(concept);
		// copy the concept to static attribute in root class:
		WholeSystem.getConceptsRegister().add(concept);			
    }
    ( < SEPARATORS > )*
}

// list of sentences, each one per line 
void parseSystemVocabulary(VocabularyTable vocabularyTable) : {} 
{
   ( line(vocabularyTable) )* < EOF >
}
void line(VocabularyTable vocabularyTable) : {Token tokenLeft; Token tokenRight;}  
{
	tokenLeft = < TERM > (< SEPARATORS >)* < ARROW > (< SEPARATORS >)* tokenRight = < TERM > 
    {
		vocabularyTable.put(tokenLeft,tokenRight);
    }
    ( < SEPARATORS > )*
}

// list of concepts, separate for comma or new line
void parseUselessConcepts(UselessConceptsTable uselessConceptsTable) : {} 
{
   ( elementUselessConcept(uselessConceptsTable) )* < EOF >
}
void elementUselessConcept(UselessConceptsTable uselessConceptsTable) : {Token token;}  
{
	token = < TERM >
    {
		// copy the useless concept to static attribute in root class:
		WholeSystem.getUselessConceptsTable().insert(token.image.trim());			
    }
    ( < SEPARATORS > )*
}


